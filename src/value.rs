use sequential::Sequential;


with_variants_array!{
#[derive(Debug)]
#[derive(Clone, Copy)]
#[derive(Eq, PartialEq, Hash)]
#[derive(Ord, PartialOrd)]
pub enum Value {
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
    Ace
}}


impl Value {
    inverted_match_constructor! {
        pub fn from_char(char) -> Self { /* generated by inverted_match_constructor */ }
        pub fn to_char(self) -> char {
            match self {
                Value::Two   => '2',
                Value::Three => '3',
                Value::Four  => '4',
                Value::Five  => '5',
                Value::Six   => '6',
                Value::Seven => '7',
                Value::Eight => '8',
                Value::Nine  => '9',
                Value::Ten   => 'T',
                Value::Jack  => 'J',
                Value::Queen => 'Q',
                Value::King  => 'K',
                Value::Ace   => 'A'
            }
        }
    }

    inverted_match_constructor! {
        pub fn from_serial(usize) -> Self { /* generated by inverted_match_constructor */ }
        pub fn to_serial(self) -> usize {
            match self {
                Value::Two   => 0,
                Value::Three => 1,
                Value::Four  => 2,
                Value::Five  => 3,
                Value::Six   => 4,
                Value::Seven => 5,
                Value::Eight => 6,
                Value::Nine  => 7,
                Value::Ten   => 8,
                Value::Jack  => 9,
                Value::Queen => 10,
                Value::King  => 11,
                Value::Ace   => 12
            }
        }
    }

    pub fn lowest() -> Self { Value::Two }
}


impl Sequential for Value {
    fn consequent(&self) -> Option<Self> {
        match *self {
            Value::Ace => None,
            _          => Some(Self::from_serial(self.to_serial() + 1))
        }
    }
}


impl std::fmt::Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {
        write!(f, "{}", self.to_char())
    }
}


/*
pub struct ValueStats {
    stats: [u8; 13 /* Value::VARIANTS_NUM */],
}


impl ValueStats {
    pub fn iter_sorted_val_desc(self) -> Box<Iterator<Item=(Value, u8)>> { Box::new(
        self.stats.iter().rev().enumerate().filter_map(|(id, &count)| {
            if count > 0 {
                Some((Value::from_id(id), count))
            } else {
                None
            }
        })
    )}

    pub fn sequences(&self) -> ValueSequences {
        ValueSequences::new(self)
    }
}


impl iter::FromIterator<Value> for ValueStats {
    fn from_iter<I>(values: I) -> Self where I: IntoIterator<Item=Value> {
        let mut stats = [0u8; Value::VARIANTS_NUM];
        for value in values {
            stats[value.id() as usize] += 1;
        }
        ValueStats { stats: stats }
    }
}

pub struct ValueSequences<T> {
    iter: T
}


impl<T> ValueSequences<T> {
    fn new(stats: &ValueStats) -> Self {
        ValueSequences { iter:
            stats
            .iter()
            .enumerate()
            .groupby(|&(value_id, count)| count == 0).by_ref()
            .filter_map(|zero_count, group|
                if zero_count {
                    None
                } else {
                    Some(group.fold(None, |acc, (value_id, &_)| {
                        match acc {
                            None               => Some((Value::from_id(value_id), 1)),
                            Some((value, len)) => Some((Value::from_id(value_id), len + 1)),
                        }
                    }))
                }
            )
        }
    }
}


impl<T> Iterator for ValueSequences<T> {
    type Item = T::Item;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }
}
*/
