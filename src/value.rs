use sequential::{Sequential, LowBound};


with_variants_array!{
#[derive(Debug)]
#[derive(Clone, Copy)]
#[derive(Eq, PartialEq, Hash)]
#[derive(Ord, PartialOrd)]
pub enum Value {
    Two,
    Three,
    Four,
    Five,
    Six,
    Seven,
    Eight,
    Nine,
    Ten,
    Jack,
    Queen,
    King,
    Ace
}}


impl Value {
    inverted_match_constructor! {
        pub fn from_char(char) -> Self { /* generated by inverted_match_constructor */ }
        pub fn to_char(self) -> char {
            match self {
                Value::Two   => '2',
                Value::Three => '3',
                Value::Four  => '4',
                Value::Five  => '5',
                Value::Six   => '6',
                Value::Seven => '7',
                Value::Eight => '8',
                Value::Nine  => '9',
                Value::Ten   => 'T',
                Value::Jack  => 'J',
                Value::Queen => 'Q',
                Value::King  => 'K',
                Value::Ace   => 'A'
            }
        }
    }

    inverted_match_constructor! {
        pub fn from_serial(usize) -> Self { /* generated by inverted_match_constructor */ }
        pub fn to_serial(self) -> usize {
            match self {
                Value::Two   => 0,
                Value::Three => 1,
                Value::Four  => 2,
                Value::Five  => 3,
                Value::Six   => 4,
                Value::Seven => 5,
                Value::Eight => 6,
                Value::Nine  => 7,
                Value::Ten   => 8,
                Value::Jack  => 9,
                Value::Queen => 10,
                Value::King  => 11,
                Value::Ace   => 12
            }
        }
    }

    pub fn prev(&self) -> Option<Self> {
        match *self {
            Value::Two => None,
            _          => Some(Self::from_serial(self.to_serial() - 1))
        }
    }
}


impl LowBound for Value {
    fn lowest() -> Self { Value::Two }
}


impl Sequential for Value {
    fn consequent(&self) -> Option<Self> {
        match *self {
            Value::Ace => None,
            _          => Some(Self::from_serial(self.to_serial() + 1))
        }
    }
}


impl std::fmt::Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {
        write!(f, "{}", self.to_char())
    }
}


#[cfg(test)]
mod test {
    use super::Value;
    use sequential::{Sequential, LowBound};
    use super::Value::*;

    #[test]
    fn test() {
        assert_eq!(Value::VARIANTS_NUM, 13);
        assert_eq!(Value::VARIANTS[0], Two);
        assert_eq!(Value::lowest(), Two);
        assert_eq!(Ace.prev(), Some(King));
        assert_eq!(Two.prev(), None);
        assert_eq!(Ace.consequent(), None);
        assert_eq!(Two.consequent(), Some(Three));
    }
}
