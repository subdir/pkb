use std::iter::FromIterator;
use std::slice;
use std::iter;
use std::vec;

with_variants_array! {
#[derive(Debug)]
#[derive(Clone, Copy)]
#[derive(Eq, PartialEq, Hash)]
pub enum Suit {
    Spades,
    Hearts,
    Diamonds,
    Clubs
}}


impl Suit {
    inverted_match_constructor! {
        pub fn from_char(char) -> Self { /* generated by inverted_match_constructor */ }
        pub fn to_char(self) -> char {
            match self {
                Suit::Spades => 'S',
                Suit::Hearts => 'H',
                Suit::Diamonds => 'D',
                Suit::Clubs => 'C'
            }
        }
    }

    inverted_match_constructor! {
        pub fn from_serial(usize) -> Self { /* generated by inverted_match_constructor */ }
        pub fn to_serial(self) -> usize {
            match self {
                Suit::Spades => 0,
                Suit::Hearts => 1,
                Suit::Diamonds => 2,
                Suit::Clubs => 3
            }
        }
    }
}


impl std::fmt::Display for Suit {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {
        write!(f, "{}", self.to_char())
    }
}

/*
pub struct SuitStats {
    stats: [u8; 4 /* Suit::VARIANTS_NUM */],
}


impl SuitStats {
    pub fn iter(self) -> Box<Iterator<Item=(Suit, u8)>> { Box::new(
        self.stats.iter()
        .enumerate()
        .filter_map(|(id, &count)| {
            if count > 0 {
                Some((Suit::from_serial(id), count))
            } else {
                None
            }
        })
    )}
}


impl FromIterator<Suit> for SuitStats {
    fn from_iter<I>(suits: I) -> Self where I: IntoIterator<Item=Suit> {
        let mut stats = [0u8; Suit::VARIANTS_NUM];
        for suit in suits {
            stats[suit.to_serial()] += 1;
        }
        SuitStats { stats: stats }
    }
}
*/
